# 进程管理

## 进程与程序

进程是运行中的程序。一个运行着的程序，可能有多个进程。进程在操作系统中执行特定的任务。

程序是存储在磁盘上，包含可执行机器指令和数据的静态实体。进程或者任务是处于活动状态的计算机程序。

## 进程的分类

进程一般分为交互进程、批处理进程和守护进程三类。

守护进程总是活跃的，一般是后台运行。守护进程一般是由操作系统在开机时通过脚本自动激活启动，或者由超级用户root来启动。

## 查看进程

`ps` 以简略方式显示当前用户有控制终端的进程信息

### BSD风格常用选项

`ps axu`

* `a` - 所有用户有控制终端的进程
* `x` - 包括无控制终端的进程
* `u` - 以详尽方式显示
* `w` - 以更大列宽显示

### SVR4风格常用选项

`ps -efl`

* `-e或-A` - 所有用户的进程
* `-a` - 当前终端的进程
* `-u 或用户名或用户ID` - 特定用户的进程

* `-g 组名或组ID` - 特定组的进程
* `-f` - 按完成格式显示
* `-F` - 按更完整格式显示
* `-l` - 按长格式显示

### 进程信息列表

* `USER/UID`：进程属主

* `PID`：进程ID

* `%CPU/C`：CPU使用率

* `%MEM`：内存使用率

* `VSZ`：占用虚拟内存大小（KB）

* `RSS`：占用物理内存大小（KB）

* `TTY`：终端次设备号，`?`表示无控制终端，如后台进程

* `STAT/S`：进程状态，可取以下值：
    * `0` - 就绪。等待被调度。
    * `R` - 运行。Linux下没有0状态，就绪状态也用R表示。
    * `S` - 可唤醒睡眠。系统终端，获得资源，收到信号，都可被唤醒，转入运行状态。
    * `D` - 不可唤醒睡眠。只能被`wake_up`系统调用唤醒。
    * `T` - 暂停。收到`SIGSTOP`信号转入暂停状态，收到`SIGCONT`信号转入运行状态。
    * `W` - 等待内存分页（2.6内核以后被废弃）
    * `X` - 死亡。不可见。
    * `Z` - 僵尸。已停止运行，但其父进程尚未获取其状态。
    * `<` - 高优先级。
    * `N` - 低优先级。
    * `L` - 有被锁到内存中的分页。实时进程和定制IO。
    * `s` - 会话首进程。
    * `l` - 多线程化进程。
    * `+` - 在前台进程组中。

* `START/STIME`：进程开始时间。
* `TIME`： 进程运行时间。
* `COMMAND`：进程指令。
* `F`：进程标志。可由下列值取和：
    * `1` - 通过`fork`产生但是没有`exec`
    * `4` - 拥有超级用户特权
* `PPID`：父进程ID。
* `NI`：进程nice值，-20到19，通过系统调用或命令修改。
* `PRI`：进程优先级。静态优先级=80+nice，60到99，值越小优先级越高。内核在静态优先级的基础上，根据进程的交互性计算得到实际（动态）优先级，以体现对IO消耗型进程的奖励，和对处理器消耗型进程的惩罚。
* `ADDR`：内核进程的内存地址。普通进程显示`-`。
* `SZ`：占用虚拟内存页数。
* `WCHAN`：进程正在等待的内核函数或事件。
* `PSR`：进程被绑定到哪个处理器。

### 父进程、子进程、孤儿进程、僵尸进程

内核进程(0)

父进程启动子进程后，子进程在操作系统的调度下与其父进程同时运行。

子进程先于父进程结束，子进程向父进程发送`SIGCHLD(17)`信号，父进程收回子进程相关资源。

父进程先于子进程结束，子进程成为孤儿进程，同时被`init`进程手痒，即成为`init`进程的子进程。

子进程先于父进程结束，但父进程没有回收子进程的相关资源，该子进程即成为僵尸进程。

### 进程标识符（进程ID）

每个进程都有一个以非负整数表示的唯一标识，即进程ID/PID。

进程ID在任何时刻都是唯一的，但可以重用，但一个进程退出时，其进程ID就可以被其他进程使用。

延迟重用。

```
#include <unistd.h>
getpid  - 获取进程ID
getppid - 获取父进程ID
getuid  - 获取实际用户ID
geteuid - 获取有效用户ID
getgid  - 获取实际组ID
getegit - 获取有效组ID
```

进程访问权限由其有效用户ID和有效组ID决定。通过此方法可以使进程获得比登录用户更高的权限。比如通过passwd命令修改登录口令。

`/usr/bin/passwd`文件中存放所有用户的口令信息，仅root用户可写，但事实上任何用户都可以修改自己的登录口令，即任何用户都可以通过`/usr/bin/passwd`程序写该文件。因为该程序有设置用户ID位，且其属主为root。任何用户登录系统，执行passwd命令所启动的进程，其有效用户ID均为root，对/etc/passwd文件有写权限。

## fork

```
#include <unistd.h>
pid_t fork(void);
```

* 创建一个子进程，失败返回-1
* 调用一次，返回两次。在父进程中返回子进程PID，在子进程中返回0。利用返回值的不同，可以分别为父子进程编写不同的处理分支。
* 子进程是父进程的副本，子进程获得父进程数据段和堆栈段（包括IO流缓冲区）的拷贝，但子进程共享父进程的代码段。
* 函数调用后，父子进程各自继续运行，其先后顺序不确定。某些实现可以保证子进程先被调度。
* 函数调用后，父进程的文件描述符表（进程表）也会被复制到子进程中，二者共享同一个文件表。
* 总进程数或实际用户ID所拥有的进程数，超过系统限制，该函数将失败。
* 一个进程如果希望创建自己的副本并执行同一份代码，或希望与另一个程序并发地运行，都可以使用该函数。
* 孤儿进程与僵尸进程。

注意：

fork之前的代码只有父进程执行，fork之后的代码父子进程都有机会执行，受代码逻辑的控制而进入不同分支。

## vfork

```
#include <unistd.h>
pid_t vfork(void);
```

该函数的功能与fork基本相同，二者的区别：

* 调佣`vfork`创建子进程时并不复制父进程的地址空间，子进程可以通过`exec`函数族直接启动另一个进程替换自身，进而提高进程创建效率。
* `vfork`调用之后，子进程先被调度。

## 进程的正常退出

从main函数中return。函数return意味着进程的结束，和普通函数意义不一样。

```
int main(...) {
	...
	return x;
}
```

等价于

```
int main(...) {
	...
	exit(0);
}
```

调用标准C语言的exit函数

```
#include <stdlib.h>
void exit(int status);
```

调用进程退出，其父进程调用`wait/waitpid`函数返回status的低8位。

进程退出前，先调用所有实现通过`atexit/on_exit`函数注册的函数，冲刷并关闭所有仍处于打开状态的标准IO流，删除所有通过tmpfile函数创建的文件。

```
#include <stdlib.h>
int atexit(
	void(*function)(void) // 函数指针，指向进程退出前需要被调用的函数。该函数没有参数和返回值。
);
返回值：成功返回0，失败返回非零

int on_exit(
	void (*function)(int, void*), // 指向进程退出前需要被调用的函数，第一个参数来自exit函数的status参数，第二个参数来自                                     // on_exit函数的arg参数
	void* arg //任意指针，将作为第二个参数传递给function指向的函数
);
返回值：成功返回0，失败返回非零。
```

用EXIT_SUCCESS/EXIT_FAILURE常量宏作为参数，调用exit函数表示成功/失败，提高平台兼容性。

该函数不会返回。

该函数的视线调用了`_exit/_Exit`函数

### 调用 _exit _Exit函数

```
#include <unistd.h>
void _exit(int status);
```

调用进程退出，其父进程调用`wait/waitpid`函数返回status的低8位。

进程退出前，先关闭所有仍处于打开状态的文件描述符，将其所有子进程托付给init进程（PID为1的进程）收养，向父进程递送`SIGCHILD`信号。

该函数不会返回。

该函数有一个完全等价的标准C版本：

```
#include <stdlib.h>
void _Exit(int status);
```

进程最后一个线程执行了返回语句。

进程最后一个线程调用`pthread_exit`函数。

## 进程异常终止

调用abort函数，产生SIGABRT信号。

进程接收到某些信号。

最后一个线程对”取消“请求做出响应。

## wait/waitpid

```
#include <sys/types.h>
#include <sys/wait.h>

pid_t wait(int* status);

pid_t waitpid(pit_t pid, int* status, int options);

返回值：成功返回终止子进程的PID，失败返回-1。
```

* 当一个进程正常或异常终止时，内核向其父进程发送`SIGCHILD`信号。父进程可以忽略该信号，或者提供一个针对该信号的处理函数，默认为忽略。

* 父进程调用wait函数。

    * 若所有子进程都在运行，则阻塞。
    * 若有一个子进程终止，则返回该子进程的PID和终止状态（通过status参数）。
    * 若没有需要等待子进程，则返回失败，errno为ECHILD。

* 在任何一个子进程终止前，`wait`函数只能阻塞调用进程，而`waitpid`函数可以有更多选择。

* 如果有一个子进程在`wait`函数被调用之前，已经终止并处于僵尸状态，`wait`函数会立即返回，并取得该子进程的终止状态。

* 子进程的终止状态通过输出参数status返回给调用者，若不关心终止状态，可将此参数置空。

* 子进程的终止状态可以借助`sys/wait.h`中定义的参数宏查看：

    * `WIFEXITED()`：子进程是否正常终止，是则通过`WEXITSTATUS()`宏获取子进程调用`exit/_exit/_Exit`函数，所传递参数的低8位。因此传诶`exit/_exit/_Exit`函数的参数最好不要超过255。

    * `WIFSIGNALED()`：子进程是否异常中医，是则通过`WTERMSIG()`宏获取终止子进程的信号。

    * `WIFSTOPPED()`：子进程是否处于暂停，是则通过`WSTOPSIG()`宏获取暂停子进程的信号。

    * `WIFCONTINUED()`：子进程是否暂停之后继续运行。
      希望在所有子进程都处于活动状态的情况下，不要阻塞。

希望可以并回收某个特定的子进程，而不是随便收一个。
```
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int* status, int options);

返回值：成功返回所回收子进程的PID，失败返回-1
```

`pid`：正整数表示所要等待并回收那个特定子进程的pid；-1表示等待并回收任意子进程

`status`：输出所回收子进程的终止状态（正常终止的退出码或异常终止的被杀信号），置NULL表示不输出终止状态。

`options`：`0/NULL`表示阻塞模式；`WNOHANG`表示非阻塞模式，调用该函数时，如果所有子进程都在运行，则立即返回0，而不发生阻塞。

`waitpid(-1, &status, 0) <=> wait(&status)`