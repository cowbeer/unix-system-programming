## 错误处理

### 通过函数返回值表示错误

* 返回合法值表示成功，返回非法值表示失败
* 返回有效指针表示成功，返回空指针（NULL或0xFFFFFFFF）表示失败

* 返回0表示成功，返回-1表示失败，不输出数据或通过指针或引用型参数输出数据
* 永远成功，如printf

### 通过errno表示错误

```
#include <errno.h>
```

* 根据`errno`得到错误编号

* 将`errno`转换为有意义的字符串

```
#include <string.h>
char* strerror(int errnum);

#include <stdio.h>
void perror(const char* s);

printf("%m");
```

* `errno`在函数执行成功的情况下不会被修改，因此不能以`errno`非零作为错误发生判断依据
* `errno`是一个全局变量，其值随时可能发生变化

## 环境变量

### 环境表

* 每个程序都会收到一张环境表，是一个以NULL指针结尾的字符指针数组

* 全局变量environ保存环境表的起始地址

```
getenv - 根据name获得value
putenv - 以name=value的形式设置环境变量，name不存在就添加，存在就覆盖其值
setenv - 根据name设置value，注意最后一个参数表示，若name已经存在是否覆盖其值
unsetenv - 删除环境变量
clearenv - 清空环境变量，environ=NULL
```

## 内存管理

|        |        |                            |            |
| ------ | ------ | -------------------------- | ---------- |
| 用户层 | STL    | 自动分配/释放内存资源      | 调用C++    |
|        | C++    | new/delete，构造/析构      | 调用标C    |
|        | 标C    | malloc/calloc/realloc/free | 调用POSIX  |
|        | POSIX  | brk/sbrk                   | 调用Linux  |
|        | Linux  | mmap/munmap                | 调用Kernel |
| 系统层 | Kernel | kmalloc/vmalloc            | 调用Driver |
|        | Driver | get_free_page              |            |

## 进程映像

程序是保存在磁盘上的可执行文件。

运行程序时，需要将可执行文件加载到内存，形成进程。

一个程序（文件）可以同时存在多个进程（内存）。

进程在内存空间中的布局就是进程映像，从低地址到高地址依次为：

代码区（text）：可执行指令、字面值常量、具有常属性的全局和静态局部变量。只读。

数据区（data）：初始化的全局和静态局部变量。

BSS区：未初始化的全局和静态局部变量。进程一经加载，此区即被清零。

数据区和BSS区有时被称为全局区或静态区。

堆区（heap）：动态分配内存。从低地址向高地址扩展。

栈区（stack）：非静态局部变量，包括函数的参数和返回值。从高地址向低地址扩展。

堆区和栈区之间存在一块间隙，一方面为堆和栈的增长预留空间。同时，共享库、共享内存等亦位于此。

## 虚拟内存

每个进程都有各自相互独立的4G字节虚拟地址空间。

用户程序中使用的都是虚拟地址空间中的地址，永远无法直接访问实际物理内存地址。

虚拟内存到物理内存的映射由操作系统动态维护。

虚拟内存一方面保护了操作系统的安全，另一方面允许应用程序使用比实际物理内存更大的地址空间。

4G进程地址空间分成两部分[0,3G)为用户空间，[3G,4G)为内核空间。

用户空间中的代码，不能直接访问内核空间中的代码和数据，但可以通过系统调用进入内核状态，间接的与系统内核交互。

对内存的越权访问，或视图访问没有映射到物理内存的虚拟内存，将导致错误。

用户空间对应进程，进程一切换，用户空间即随之变换。内核空间由操作系统内核管理，不会随进程切换而改变。内核空间由内核根据独立且唯一的页表`init_mm.pgd`进程内存映射，而用户空间的页表则每个进程一份。

每个进程的内存空间完全独立。不同进程之间交换虚拟内存地址是毫无意义的。

标准库内部通过一个双向链表，管理在堆中动态分配的内存。malloc函数分配内存时会附加若干（通常是12个）字节存放控制信息。改信息一旦被意外损坏，可能在后续操作中引发异常。

虚拟内存到物理内存的映射以页（4K=4096字节）为单位。通过malloc函数首次分配内存，至少映射33页。即使通过free函数释放掉全部内存，最初的33页仍然保留。

```
#include <unistd.h>
int getpagesize(void);
返回内存页的字节数
```

## 内存管理APIs

### 增量方式分配内存

```
#include <unistd.h>
void* sbrk(
	intptr_t increment // 增量内存（以字节为单位）
);
返回上次调用brk/sbrk后的末尾地址，失败返回-1
increment取值：
0 - 获取末尾地址
>0 - 增加的内存大小
<0 - 释放的内存大小
```

内部维护一个指针，指向当前堆内存最后一个字节的下一个位置。sbrk函数根据增量参数调整该指针的位置，同时返回该指针原来的位置。若发现页耗尽或空闲，则自动追加或取消页映射。

### 修改虚拟内存块末尾地址

```
#include <unistd.h>
int brk(
	void* end_data_segment; // 内存块末尾地址
);
成功返回0，失败返回-1
```

内部维护一个指针，指向当前堆内存最后一个字节的下一个位置。brk函数根据指针参数设置该指针的位置。若发现页耗尽或空闲，则自动追加或取消页映射。

sbrk/brk底层维护一个指针位置，以页（4K）为单位分配和释放虚拟内存。可以用sbrk分配内存，用brk释放内存。

### 创建虚拟内存到物理内存或文件的映射

```
#include <sys/mman.h>
void* mmap(
	void* start, // 映射区内存起始地址
);
```


